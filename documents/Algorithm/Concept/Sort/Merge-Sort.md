# 병합정렬(Merge Sort)

## Concept
일단 반으로 나누고 나중에 합쳐서 정렬하면 어떨까?
## Content
퀵정렬과 마찬가지로 분할 정복 알고리즘으로 정렬하는 방법이다. <br>
반으로 나눠서 정렬하기 때문에 O(N * log N) 의 시간복잡도를 가진다. <br>
피벗값이 없기 때문에 항상 같은 시간복잡도를 보장한다는점이 특징이다. <br>
먼저 우선 주어진 배열의 원소를 전부 반으로 쪼갠다. (결국 모든 원소가 단일 원소로 존재하게 된다. 또한 이 상태는 정렬된 상태로 볼 수 있다.) <br>
그 다음 바로 옆의 원소와 정렬하면서 합친다. <br>
이 단계들을 계속 반복하다보면 log N번만큼 반복했을때 정렬이 완성되게 되는데, 총 N(너비)개의 원소를 log N(높이)번 정렬을 수행하므로 O(N * log N) 의 시간복잡도를 가질 수 있는것이다.<br>
그럼 왜 너비를 N으로 단정 할 수 있는지 알아보자.<br>
처음 정렬에 소요되는 횟수는 N이다. 단일 개체이기때문에 개수만큼 따지면 되기 떄문이다.<br>
그 다음 2개씩 뭉쳐있는 애들을 따져보자. 각 2뭉치 원소는 이미 정렬된 원소들이 합쳐진것이라는것에 유의해야한다.<br>
예를들어 [3, 4], [1, 2] 가 있다고 치자.<br>
그리고 이 원소들을 다시 크기 순서대로 [a, b, c, d] 에 넣어 정렬한다.<br>
각 집합에서 가장 작은 3과 1을 비교해서 가장 작은것을 a에 넣는다.<br>
다시 3과 그 다음 원소인 2를 비교해서 작은것을 b에 넣는다.<br>
이 경우 남은 원소가 없어 3과 4를 각각 c와 d에 넣는다.<br>
N번만에 원소비교가 끝났다. 나머지 무리들도 이런식으로 비교정렬하게 되므로 N번이 소요되는것이다.
## Summary
시간복잡도는 O(N * log N) 이다. <br>
## Code
``` C++
#include <stdio.h>

int main(void) {

  return 0;
}
```
## Review

## Question
* Worst Case 찾아보기
## Reference
* 나동빈님 유튜브 - https://www.youtube.com/watch?v=8ZiSzteFRYc&list=PLRx0vPvlEmdDHxCvAQS1_6XV4deOwfVrz&index=5